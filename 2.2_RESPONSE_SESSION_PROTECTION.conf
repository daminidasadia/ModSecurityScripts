############################################
# Validates the RESPONSE for session protection.
############################################

#Enables content manipulation
SecContentInjection On
SecStreamOutBodyInspection On
SecDisableBackendCompression On

# Initialize the session collection when we receive the cookie from the server
SecRule RESPONSE_HEADERS:/Set-Cookie2?/ "^(?i:JSESSIONID)=(.*?);" "chain,phase:3,id:'221',t:none,pass,nolog,capture,setsid:%{TX.1},setvar:session.valid=1,setvar:session.ip=%{REMOTE_ADDR}"
SecRule REQUEST_HEADERS:User-Agent "(.*)" "chain,t:none,t:sha1,t:hexEncode,setvar:session.uahash=%{matched_var}"
SecRule UNIQUE_ID "(.*)" "t:none,t:sha1,t:hexEncode,setvar:session.csrf_token=%{matched_var}"

# After the logout we remove the user association redirect to "/?nar" (need a refresh) to synchonize the session state
SecRule REQUEST_URI "/logout" "phase:3,id:222,nolog,setvar:!session.user,redirect:'/?nar',skipAfter:END_RESPONSE_SESSION_RULES"

<Location /login>
  #If there is a redirect after the login post we undestand that it's successful and associate the user
  SecRule REQUEST_METHOD "@streq GET" "phase:3,id:223,chain,t:none,nolog,pass"
  SecRule &RESPONSE_HEADERS:Location "@eq 1" setvar:SESSION.user=%{ARGS.login}
</Location>

# If we 'Need A Refresh' a reload script is added to force a new request and synchonize the new session
SecRule REQUEST_URI "^(\/\?nar)$" "phase:4,id:225,chain,pass,nolog,skipAfter:END_RESPONSE_SESSION_RULES"
SecRule STREAM_OUTPUT_BODY "@rsub s/<head>/<head><script type=\"text\/javascript\">document.location.href=\"\/\";<\/script>/"

# On valid get requests we inject the CSRF token into the forms
SecRule REQUEST_METHOD "@streq GET" "phase:4,id:224,chain,t:none,pass,nolog"
SecRule SESSION:VALID "@eq 1" "chain"
SecRule STREAM_OUTPUT_BODY "@rsub s/<\/form>/<input type=\"hidden\" name=\"csrf_token\" value=\"%{session.csrf_token}\"><\/form>/"

SecMarker END_RESPONSE_SESSION_RULES
