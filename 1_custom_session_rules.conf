# FIXME: Pending checks: malformed sessionid / idle session / multiple sessions per user / danger score

#Enables content manipulation
SecContentInjection On
SecStreamOutBodyInspection On
SecDisableBackendCompression On

###############################
SecMarker BEGIN_REQUEST_RULES
###############################

#Ignore all rules for the static file requests that have no parameters
SecRule REQUEST_METHOD "@pm GET HEAD" "id:'11',chain,phase:1,t:none,nolog,pass"
SecRule REQUEST_URI "^(\/resources)|(.ico)$" "chain"
SecRule &ARGS "@eq 0" "ctl:ruleEngine=Off,ctl:auditEngine=Off"

# If there is no session cookie on the header, we skip all the session checks (will apply them once the session is created in the server)
SecRule &REQUEST_COOKIES:JSESSIONID "@eq 0" "phase:1,id:12,pass,nolog,skipAfter:BEGIN_RESPONSE_RULES"

# Validates the session
SecRule REQUEST_COOKIES:JSESSIONID "(.*)" "phase:1,id:'13',t:none,nolog,pass,setsid:%{matched_var}"

# New session, we store ip and user-agent and generate a csrf token.
SecRule SESSION:IS_NEW "@eq 1" "phase:1,id:02,chain,capture,pass,auditlog,setvar:SESSION.ip=%{REMOTE_ADDR},setvar:SESSION.valid=1"
SecRule REQUEST_HEADERS:User-Agent "(.*)" "chain,t:none,t:sha1,t:hexEncode,setvar:session.uahash=%{matched_var}"
SecRule UNIQUE_ID "(.*)" "t:none,t:sha1,t:hexEncode,setvar:session.csrf_token=%{matched_var}"

#Checks if the session is flagged as invalid
SecRule SESSION:VALID "!@eq 1" "phase:1,id:'133',t:none,block,msg:'Session flagged as invalid: %{sessionid} %{session.valid} %{session.csrf_token}'"

#Checks for ip or user-agent changes during the session
SecRule SESSION:IP "!@streq %{REMOTE_ADDR}" "phase:2,id:15,block,msg:'Session hijacking Detected: Expected IP address .%{SESSION.ip}. but got %{REMOTE_ADDR}'"
#SecRule REQUEST_HEADERS:User-Agent "!@streq %{SESSION.uahash}" "phase:2,id:16,t:none,t:sha1,t:hexEncode,block,msg:'Session hijacking Detected: Expected User-Agent hash %{SESSION.uahash} but got %{matched_var}'"

#On every POST checks the CSRF token.
SecRule REQUEST_METHOD "@streq POST" "phase:2,id:17,chain,capture,t:none,block,auditlog,setvar:TX.csrf_token=%{ARGS.csrf_token},msg:'Invalid CSRF token. Expected %{session.csrf_token} but received %{ARGS.csrf_token}'"
SecRule TX:csrf_token "^$" "chain"
SecRule TX:csrf_token "!@streq %{SESSION.csrf_token}"

###############################
SecMarker BEGIN_RESPONSE_RULES
###############################

# On the first access we reload the page to load the csrf tokens in the forms
SecRule REQUEST_METHOD "@streq GET" "phase:4,id:52,chain,t:none,pass,nolog"
SecRule &REQUEST_COOKIES:JSESSIONID "@eq 0" "chain"
SecRule STREAM_OUTPUT_BODY "@rsub s/<head>/<head><script type=\"text\/javascript\">location.reload();<\/script>/"

# On every GET we add the CSRF token to the forms
SecRule REQUEST_METHOD "@streq GET" "phase:4,id:50,chain,t:none,pass,nolog"
SecRule &REQUEST_COOKIES:JSESSIONID "@eq 1" "chain"
SecRule STREAM_OUTPUT_BODY "@rsub s/<\/form>/<input type=\"hidden\" name=\"csrf_token\" value=\"%{session.csrf_token}\"><\/form>/"

# Check for successful authentication
<Location /login>
  #If there is a redirect after the login post we undestand that it's successful
  SecRule REQUEST_METHOD "@streq POST" "phase:3,id:51,chain,t:none,nolog,pass"
  SecRule &RESPONSE_HEADERS:Location "@eq 1" setvar:SESSION.user=%{ARGS.login}
</Location>

# Disassociate user from session
SecRule REQUEST_URI "/logout" "phase:3,id:53,nolog,pass,setvar:!session.user"

SecMarker END_RESPONSE_RULES
